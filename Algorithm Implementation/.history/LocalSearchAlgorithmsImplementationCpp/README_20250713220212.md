# Local Search Algorithms Implementation 🏔️

A comprehensive C++ implementation of local search algorithms that focus on finding good solutions efficiently without exploring the entire search space.

---

## 📋 Table of Contents

- Algorithms Implemented
- How Algorithms Work
- Applications
- Complexity Analysis
- Input & Output Examples
- Usage

---

## 🚀 Algorithms Implemented

- Hill Climbing 🏔️  
- Beam Search 🔦  

---

## 🧠 How Algorithms Work

### 🏔️ Hill Climbing

A greedy local search that moves to the best neighboring state. Continues until reaching a local optimum where no neighbor is better than the current state. Simple but can get stuck in local maxima.

### 🔦 Beam Search

Systematic search that maintains a fixed number of best nodes (beam width) at each level. Combines breadth-first exploration with heuristic pruning to balance completeness and efficiency.

---

## 🎯 Applications

### 🏔️ Hill Climbing Applications

## Usage

Each algorithm is implemented as a C++ class with methods to configure parameters, run the search, and retrieve the best solution found.

Example usage:

```cpp
#include "HillClimbing.h"

int main() {
    HillClimbing hc;
    hc.setInitialSolution(...);
    hc.setMaxIterations(1000);
    hc.run();
    auto best = hc.getBestSolution();
    // Process best solution
    return 0;
}
```

## References

- Russell, S., & Norvig, P. (2010). Artificial Intelligence: A Modern Approach.
- Michalewicz, Z. (1996). Genetic Algorithms + Data Structures = Evolution Programs.
- Glover, F., & Laguna, M. (1997). Tabu Search.

This project is designed to provide a foundation for experimenting with local search techniques in C++.
